`include "constants.h"
`include "disciplines.h"

`define z0          50.0

`define C0          299792458.0
`define MU0         12.566370614e-7
`define Z0          376.73031346958504364963

`define pi          3.1415926535897932384626433832795029
`define pi_over_2   1.5707963267948966192313216916397514
`define one_over_pi 0.3183098861837906715377675267450287
`define two_over_pi 0.6366197723675813430755350534900574
`define euler       2.7182818284590452353602874713526625
`define ln2         0.6931471805599453094172321214581766

// IMPORTANT WARNING
// In c, c++, spectre, hspice natural logarithm - "log", and in VerilogA - "ln";
// In c, c++, spectre, hspice decimal logarithm - "log10", and in VerilogA - "log";

module MOPEN(p1); //  port_type: "one_pole" or "two_pole"

inout      p1;
electrical p1;

(*desc="width",                   unit="m",           type="instance"*)                      parameter real w = 1m from (0.0:inf);
(*desc="substrate permittivity relative to a vacuum", type="instance"*)                      parameter real er = 9.8 from (0.0:inf);
                                                                                             aliasparam eps = er;
(*desc="substrate height",        unit="m"            type="instance"*)                      parameter real h = 0.1m from (0.0:inf);
(*desc="conductor thickness",     unit="m"            type="instance"*)                      parameter real t = 3u from (0.0:inf);
(*desc="loss tangent",                                type="instance"*)                      parameter real tand = 2e-4 from (0.0:inf);
(*desc="metal resistivity",                           type="instance"*)                      parameter real rho = 2.2e-8 from (0.0:inf);
(*desc="surface roughness (RMS)",                     type="instance"*)                      parameter real d = 0.15e-6 from (0.0:inf);

(*desc="substrate",                                   type="instance", resolve_type="text"*) parameter string subst = "";


    analog function real sqr;
        input r;
        real r;
        sqr = r*r;
    endfunction

    analog function real cubic;
        input r;
        real r;
        cubic = r*r*r;
    endfunction

    analog function real quadr;
        input r;
        real r;
        quadr = r*r*r*r;
    endfunction

    analog function real coth;
        input r;
        real r;
        coth = 1.0/tanh(r);
    endfunction

    analog function real sech;
        input r;
        real r;
        sech = 1.0/cosh(r);
    endfunction
	real a, b, u, e, fu, zl, lambda; 
	
    analog function real calcPropagation;
        input frequency;
        real frequency;
        begin
// расчет основных параметров
            u = w / h;
            lambda = `C0 / frequency;
            a = 1 + ln((quadr(u) + sqr(u / 52)) / (quadr(u) + 0.432)) / 49 + ln(1 + cubic(u / 18.1)) / 18.7;
            b = 0.564 * pow((er - 0.9) / (er + 3), 0.053);
            e = (er + 1) / 2 + (er - 1) / 2 * pow(1 + 10 / u, -a * b);
            fu = 6 + (2 * `pi - 6) * exp(-pow(30.666 / u, 0.7528));
            zl = `Z0 / 2 / `pi / sqrt(e) * ln(fu / u + sqrt(1 + sqr(2 / u)));
			

        end
    endfunction // calcPropagation
	
analog begin

    begin : initializeInstance
    end // initializeInstance

    calcPropagation($freq);
  
//Расчет конденсатора на землю
     real dl = h * (0.102 * ((w / h) + 0.106) / ((w / h) + 0.264)) * ((1.166 + ((er + 1) / er)) * (0.9 + ln((w / h) + 2.475)));
     real cap = (sqrt(e) / ( `C0 * zl)) * dl;
//$strobe("cap= %g", cap);
     I(p1) <+ 0.7 * cap * ddt(V(p1));

end // analog

endmodule
