nature sparameter
  access = S;
endnature

nature yparameter
  access = Y;
endnature

nature zparameter
  access = Z;
endnature

discipline sparameters
  flow sparameter;
enddiscipline

discipline yparameters
  flow yparameter;
enddiscipline

discipline zparameters
  flow zparameter;
enddiscipline

`define z0          50.0

`define C0          299792458.0
`define MU0         12.566370614e-7
`define Z0          376.73031346958504364963

`define pi          3.1415926535897932384626433832795029
`define pi_over_2   1.5707963267948966192313216916397514
`define one_over_pi 0.3183098861837906715377675267450287
`define two_over_pi 0.6366197723675813430755350534900574
`define euler       2.7182818284590452353602874713526625
`define ln2         0.6931471805599453094172321214581766

// IMPORTANT WARNING
// In c, c++, spectre, hspice natural logarithm - "log", and in VerilogA - "ln";
// In c, c++, spectre, hspice decimal logarithm - "log10", and in VerilogA - "log";

module MSTEP(p1,p2) (*model_type="distributed" port_type="one_pole"*);  //  port_type: "one_pole" or "two_pole"

inout      p1,p2;
zparameters p1,p2;

(*desc="width",                   unit="m",           type="instance"*)                      parameter real w1 = 20m from (0.0:inf);
(*desc="width",                  unit="m",           type="instance"*)                       parameter real w2 = 10m from (0.0:inf);
//(*desc="dispersion model",                            type="instance", resolve_type="text"*) parameter string dispmodel = "Hammerstad";
//(*desc="model",                                       type="instance", resolve_type="text"*) parameter string model = "Wheeler";

(*desc="substrate permittivity relative to a vacuum", type="instance"*)                      parameter real er = 9.8 from (0.0:inf);
                                                                                             aliasparam eps = er;
(*desc="substrate height",        unit="m"            type="instance"*)                      parameter real h = 0.1m from (0.0:inf);
(*desc="conductor thickness",     unit="m"            type="instance"*)                      parameter real t = 3u from (0.0:inf);
(*desc="loss tangent",                                type="instance"*)                      parameter real tand = 2e-4 from (0.0:inf);
(*desc="metal resistivity",                           type="instance"*)                      parameter real rho = 2.2e-8 from (0.0:inf);
(*desc="surface roughness (RMS)",                     type="instance"*)                      parameter real d = 0.15e-6 from (0.0:inf);

(*desc="substrate",                                   type="instance", resolve_type="text"*) parameter string subst = "";


    analog function real sqr;
        input r;
        real r;
        sqr = r*r;
    endfunction

    analog function real cubic;
        input r;
        real r;
        cubic = r*r*r;
    endfunction

    analog function real quadr;
        input r;
        real r;
        quadr = r*r*r*r;
    endfunction

    analog function real coth;
        input r;
        real r;
        coth = 1.0/tanh(r);
    endfunction

    analog function real sech;
        input r;
        real r;
        sech = 1.0/cosh(r);
    endfunction


	real a, b, u, e, fu, zl;
	real a2, b2, u2, e2, fu2, zl2;

    real dwt0, weq0, ac2;
    real Cs, Ls, L1, L2, Lw1, Lw2;
    real kkk, kk1, kk2;


    analog function real calcPropagation;
        input frequency;
        real frequency;
        begin
// расчет основных параметров
            u = w1 / h;
            a = 1 + ln((quadr(u) + sqr(u / 52)) / (quadr(u) + 0.432)) / 49 + ln(1 + cubic(u / 18.1)) / 18.7;
            b = 0.564 * pow((er - 0.9) / (er + 3), 0.053);
            e = (er + 1) / 2 + (er - 1) / 2 * pow(1 + 10 / u, -a * b);
            fu = 6 + (2 * `pi - 6) * exp(-pow(30.666 / u, 0.7528));
            zl = `Z0 / 2 / `pi / sqrt(e) * ln(fu / u + sqrt(1 + sqr(2 / u)));

// расчет основных параметров
            u2 = w2 / h;
            a2 = 1 + ln((quadr(u2) + sqr(u2 / 52)) / (quadr(u2) + 0.432)) / 49 + ln(1 + cubic(u2 / 18.1)) / 18.7;
            b2 = 0.564 * pow((er - 0.9) / (er + 3), 0.053);
            e2 = (er + 1) / 2 + (er - 1) / 2 * pow(1 + 10 / u2, -a2 * b2);
            fu2 = 6 + (2 * `pi - 6) * exp(-pow(30.666 / u2, 0.7528));
            zl2 = `Z0 / 2 / `pi / sqrt(e2) * ln(fu2 / u2 + sqrt(1 + sqr(2 / u2)));


            Cs = sqrt(w1 * w2) * ((10.1 * log(er) + 2.33) * (w1 / w2) - 12.6 * log(er) - 3.17);
            Ls = h * (40.5 * ((w1 / w2) - 1) - 75 * log(w1 / w2) + 0.2 * ((w1 / w2) - 1) * ((w1 / w2) - 1));
            Lw1 = zl * sqrt(e) / `C0;
            Lw2 = zl2 * sqrt(e2) / `C0;
            L1 = (Lw1 / (Lw1 + Lw2)) * Ls;
            L2 = (Lw2 / (Lw1 + Lw2)) * Ls;

            kkk = 0.9;
            kk1 = (w1 / w2) + 0.5;
            kk2 = kk1 / 2;


        end
    endfunction // calcPropagation

analog begin

    begin : initializeInstance
    end // initializeInstance

    calcPropagation($freq);


    complex z21 = $complex(0.0, -0.5e12 / (2 * `pi * $freq * Cs / kkk));
    complex z11 = $complex(0, 2e-9 * `pi * $freq * L1 / kk1) + z21;
    complex z22 = $complex(0, 2e-9 * `pi * $freq * L2 / kk2) + z21;


    Z(p1,p1) <+ z11;
    Z(p1,p2) <+ z21;
    Z(p2,p1) <+ z21;
    Z(p2,p2) <+ z22;

end // analog

endmodule
