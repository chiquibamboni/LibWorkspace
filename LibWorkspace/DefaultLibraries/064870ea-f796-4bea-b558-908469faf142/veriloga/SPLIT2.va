
nature sparameter
  access = S;
endnature

discipline sparameters
  flow sparameter;
enddiscipline

`define z0          50.0

`define C0          299792458.0
`define MU0         12.566370614e-7

`define pi          3.1415926535897932384626433832795029
`define pi_over_2   1.5707963267948966192313216916397514
`define one_over_pi 0.3183098861837906715377675267450287
`define two_over_pi 0.6366197723675813430755350534900574
`define euler       2.7182818284590452353602874713526625
`define ln2         0.6931471805599453094172321214581766

// IMPORTANT WARNING
// In c, c++, spectre, hspice natural logarithm - "log", and in VerilogA - "ln";
// In c, c++, spectre, hspice decimal logarithm - "log10", and in VerilogA - "log";

module SPLIT2(p1,p2,p3) (*model_type="distributed" port_type="one_pole"*);  //  port_type: "one_pole" or "two_pole"

inout      p1,p2,p3;
sparameters p1,p2,p3;

(*type="instance"*) parameter real s21 = 0.707;
(*type="instance"*) parameter real s31 = 0.707;
(*type="instance"*) parameter real ISO = 100 from (0.0:inf);
(*type="instance"*) parameter real zref = 50 from (0.0:inf);
(*type="instance"*) parameter real s11 = -15;
(*type="instance"*) parameter real s22 = -15;


analog begin
    real VSWR1 = (1.0 + pow(10.0, -abs(s11) / 20.0)) / (1.0 - pow(10.0, -abs(s11)/20.0));
    real VSWR2 = (1.0 + pow(10.0, -abs(s22) / 20.0)) / (1.0 - pow(10.0, -abs(s22)/20.0));

    complex S11 = (VSWR1 - 1) / (VSWR1 + 1);
    complex S22 = (VSWR2 - 1) / (VSWR2 + 1);
    complex S23 = pow(10.0, (-abs(ISO) / 20.0));
    complex S21 = $complex(s21, 0.0);
    complex S31 = $complex(s31, 0.0);

    S(p1,p1) <+ S11;
    S(p1,p2) <+ S21;
    S(p1,p3) <+ S31;
    S(p2,p1) <+ S21;
    S(p2,p2) <+ S22;
    S(p2,p3) <+ S23;
    S(p3,p1) <+ S31;
    S(p3,p2) <+ S23;
    S(p3,p3) <+ S22;

end // analog

endmodule
