nature sparameter
  access = S;
endnature

discipline sparameters
  flow sparameter;
enddiscipline

`define z0          50.0
`define C0         299792458.0
`define pi          3.1415926535897932384626433832795029


// IMPORTANT WARNING
// In c, c++, spectre, hspice natural logarithm - "log", and in VerilogA - "ln";
// In c, c++, spectre, hspice decimal logarithm - "log10", and in VerilogA - "log";

module CLIN(p1,p2,p3,p4) (*model_type="distributed" port_type="one_pole"*);  //  port_type: "one_pole" or "two_pole"

inout      p1,p2,p3,p4;
sparameters p1,p2,p3,p4;
// Параметры компонентов


    parameter real F=100e9;
    parameter real E=9000;
    parameter real Ze=100;
    parameter real Zo=25;

    //parameter real alpha=0.00001;
   // parameter real frequency = 1e9;


    real l;
    real  alpha, beta;



 analog function real calcPropagation;
        input frequency;
        real frequency;
        begin

            // calculate propagation constants and reference impedance

            alpha = 0.00001;
            beta  =  2 * `pi * frequency / `C0;
        end
    endfunction // calcPropagation



analog begin

    begin : initializeInstance
    end // initializeInstance

    calcPropagation($freq);

    l = E * `C0 / (360 * F);

    complex g = $complex(alpha, beta);

    complex De = 2 * Ze * `z0 * cosh(g*l) + (Ze * Ze + `z0 * `z0) * sinh(g*l);
    complex Do = 2 * Zo * `z0 * cosh(g*l) + (Zo * Zo + `z0 * `z0) * sinh(g*l);

    complex Ye = Ze * `z0 / De;
    complex Yo = Zo * `z0 / Do;

    complex Xe = 0.5*(Ze * Ze - `z0 * `z0)*sinh(g*l) / De;
    complex Xo = 0.5*(Zo * Zo - `z0 * `z0)*sinh(g*l) / Do;

    complex s11 = Xe + Xo;
    complex s12 = Ye + Yo;
    complex s13 = Ye - Yo;
    complex s14 = Xe + Xo;




    S(p1,p1) <+ s11;
    S(p1,p2) <+ s12;
    S(p1,p3) <+ s13;
    S(p1,p4) <+ s14;

    S(p2,p1) <+ s12;
    S(p2,p2) <+ s11;
    S(p2,p3) <+ s14;
    S(p2,p4) <+ s13;

    S(p3,p1) <+ s13;
    S(p3,p2) <+ s14;
    S(p3,p3) <+ s11;
    S(p3,p4) <+ s12;

    S(p4,p1) <+ s14;
    S(p4,p2) <+ s13;
    S(p4,p3) <+ s12;
    S(p4,p4) <+ s11;


end // analog

endmodule
