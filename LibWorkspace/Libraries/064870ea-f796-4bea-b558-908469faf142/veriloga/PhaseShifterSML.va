
nature sparameter
  access = S;
endnature

discipline sparameters
  flow sparameter;
enddiscipline

`define zref          50.0

`define C0          299792458.0
`define MU0         12.566370614e-7
`define Z0          376.73031346958504364963

`define pi          3.1415926535897932384626433832795029
`define pi_over_2   1.5707963267948966192313216916397514
`define one_over_pi 0.3183098861837906715377675267450287
`define two_over_pi 0.6366197723675813430755350534900574
`define euler       2.7182818284590452353602874713526625
`define ln2         0.6931471805599453094172321214581766

// IMPORTANT WARNING
// In c, c++, spectre, hspice natural logarithm - "log", and in VerilogA - "ln";
// In c, c++, spectre, hspice decimal logarithm - "log10", and in VerilogA - "log";

module PhaseShiftSML(p1,p2) (*model_type="distributed" port_type="one_pole"*);  //  port_type: "one_pole" or "two_pole"

inout      p1,p2;
sparameters p1,p2;

(*type="instance", unit="degree"*) parameter real phi = 90;
(*type="instance", unit="Ohm"*) parameter real Z0 = 50 from (0.0:inf);

analog begin
    real phi2 = phi * `pi / 180;
    real r = (`zref - Z0) / (`zref + Z0);

    complex s11 = r * (1.0 - exp($complex(0.0, 2.0*phi2))) / (1.0 - r * r * exp($complex(0.0, 2.0*phi2)));
    complex s21 = ((1.0 -r * r) * exp ($complex(0.0, phi2))) / (1.0 - r * r * exp($complex(0.0, 2.0*phi2)));

    S(p1,p1) <+ s11;
    S(p1,p2) <+ s21;
    S(p2,p1) <+ s21;
    S(p2,p2) <+ s11;

end // analog

endmodule
