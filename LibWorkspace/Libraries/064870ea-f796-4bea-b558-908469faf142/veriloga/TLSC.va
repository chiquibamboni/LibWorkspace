
nature sparameter
  access = S;
endnature

nature yparameter
  access = Y;
endnature

nature zparameter
  access = Z;
endnature

discipline sparameters
  flow sparameter;
enddiscipline

discipline yparameters
  flow yparameter;
enddiscipline

discipline zparameters
  flow zparameter;
enddiscipline

`define z0          50.0

`define C0          299792458.0
`define MU0         12.566370614e-7


`define pi          3.1415926535897932384626433832795029
`define pi_over_2   1.5707963267948966192313216916397514
`define one_over_pi 0.3183098861837906715377675267450287
`define two_over_pi 0.6366197723675813430755350534900574
`define euler       2.7182818284590452353602874713526625
`define ln2         0.6931471805599453094172321214581766

// IMPORTANT WARNING
// In c, c++, spectre, hspice natural logarithm - "log", and in VerilogA - "ln";
// In c, c++, spectre, hspice decimal logarithm - "log10", and in VerilogA - "log";

module TLSC(p1) (*model_type="distributed" port_type="one_pole"*);  //  port_type: "one_pole" or "two_pole"

inout      p1;
zparameters p1;

    parameter real F=100e9;
    parameter real E=9000;
    parameter real Z0=250;
    parameter real alpha=0;
   // parameter real frequency = 1e9;


    real l;
    real  omega;
    real za;


 analog function real calcPropagation;
        input frequency;
        real frequency;
        begin

            // calculate propagation constants and reference impedance

            alpha = 0;
            omega = 2 * `pi * frequency;
            za = -0*1e-40;

            l = E * `C0 / (360*F);


        end
    endfunction // calcPropagation


analog begin

    begin : initializeInstance
    end // initializeInstance

    calcPropagation($freq);


    //l = E * `C0 / (360*F);
    real zb = Z0*(tan(omega*l/`C0));
    complex zvh = $complex(za, -zb);

    //complex zb = -Z0*(1/tan(omega*l/`C0));



    //complex zvh = $complex(z0a, z0b);

    Z(p1,p1) <+ zvh;

end // analog

endmodule
