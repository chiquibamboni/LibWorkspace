
nature sparameter
  access = S;
endnature

discipline sparameters
  flow sparameter;
enddiscipline

`define z0          50.0

`define C0          299792458.0
`define MU0         12.566370614e-7
`define Z0          376.73031346958504364963

`define pi          3.1415926535897932384626433832795029
`define pi_over_2   1.5707963267948966192313216916397514
`define one_over_pi 0.3183098861837906715377675267450287
`define two_over_pi 0.6366197723675813430755350534900574
`define euler       2.7182818284590452353602874713526625
`define ln2         0.6931471805599453094172321214581766

// IMPORTANT WARNING
// In c, c++, spectre, hspice natural logarithm - "log", and in VerilogA - "ln";
// In c, c++, spectre, hspice decimal logarithm - "log10", and in VerilogA - "log";

module MLSC(p1,p2) (*model_type="distributed" port_type="one_pole"*);  //  port_type: "one_pole" or "two_pole"

inout      p1,p2;
sparameters p1,p2;

(*desc="width",                   unit="m",           type="instance"*)                      parameter real w = 1m from (0.0:inf);
(*desc="length",                  unit="m",           type="instance"*)                      parameter real l = 10m from (0.0:inf);
//(*desc="dispersion model",                            type="instance", resolve_type="text"*) parameter string dispmodel = "Hammerstad";
//(*desc="model",                                       type="instance", resolve_type="text"*) parameter string model = "Wheeler";

(*desc="substrate permittivity relative to a vacuum", type="instance"*)                      parameter real er = 9.8 from (0.0:inf);
                                                                                             aliasparam eps = er;
(*desc="substrate height",        unit="m"            type="instance"*)                      parameter real h = 0.1m from (0.0:inf);
(*desc="conductor thickness",     unit="m"            type="instance"*)                      parameter real t = 3u from (0.0:inf);
(*desc="loss tangent",                                type="instance"*)                      parameter real tand = 2e-4 from (0.0:inf);
(*desc="metal resistivity",                           type="instance"*)                      parameter real rho = 2.2e-8 from (0.0:inf);
(*desc="surface roughness (RMS)",                     type="instance"*)                      parameter real d = 0.15e-6 from (0.0:inf);

(*desc="substrate",                                   type="instance", resolve_type="text"*) parameter string subst = "";


    analog function real sqr;
        input r;
        real r;
        sqr = r*r;
    endfunction

    analog function real cubic;
        input r;
        real r;
        cubic = r*r*r;
    endfunction

    analog function real quadr;
        input r;
        real r;
        quadr = r*r*r*r;
    endfunction

    analog function real coth;
        input r;
        real r;
        coth = 1.0/tanh(r);
    endfunction

    analog function real sech;
        input r;
        real r;
        sech = 1.0/cosh(r);
    endfunction


	real a, b, u, e, fu, zl, lambda;
	real gg, fp, erf, zlf;
	real ad;
	real rsh, ds, ki, kr, ac;
	real ar1, ar2, ar;
	real alpha, beta;
	/*real aa, bb, x, w1, kk, adm, acm1, acm2, alpha_m;*/
    real dwt0, weq0, ac2;

    analog function real calcPropagation;
        input frequency;
        real frequency;
        begin
// расчет основных параметров
            u = w / h;
            lambda = `C0 / frequency;
            a = 1 + ln((quadr(u) + sqr(u / 52)) / (quadr(u) + 0.432)) / 49 + ln(1 + cubic(u / 18.1)) / 18.7;
            b = 0.564 * pow((er - 0.9) / (er + 3), 0.053);
            e = (er + 1) / 2 + (er - 1) / 2 * pow(1 + 10 / u, -a * b);
            fu = 6 + (2 * `pi - 6) * exp(-pow(30.666 / u, 0.7528));
            zl = `Z0 / 2 / `pi / sqrt(e) * ln(fu / u + sqrt(1 + sqr(2 / u)));

// Дисперсия
           gg = ((`pi * `pi) / 12) * ((er - 1) / e) * sqrt(2 * `pi * zl / `Z0);
           fp = zl / (2 * `MU0 * h);
           erf = er - ((er - e) / (1 + gg * (frequency / fp) * (frequency / fp)));
           zlf = zl * sqrt(e / erf) * (erf - 1) / (e - 1);

// Диэлектрические потери
           ad = (er / sqrt(e)) * ((e - 1) / (er - 1)) * tand * `pi / lambda;

// Потери в проводнике
           rsh = sqrt(`pi * `MU0 * rho * frequency);
           ds = rho / rsh;
           ki = exp(-1.2 * pow(zl / `Z0, 0.7));
           kr = 1 + (2 / `pi) * atan(1.4 * (d / ds) * (d / ds));
           ac = (rsh / (zl * w)) * kr * kr;

// Потери на излучение
          ar1 = 60 * (2 * `pi * frequency * h * sqrt(e) / `C0) * (2 * `pi * frequency * h * sqrt(e) / `C0);
          ar2 = ln(sqrt((e + 1) / (e - 1)));
          ar = (1 - ((e - 1) / (2 * sqrt(e))) * ar2) * ar1;

           dwt0 = ln((4 * `pi * w / t) + 1) * t / `pi;
           weq0 = w + dwt0;
           ac2 = (1 - (weq0 / 4 / h) * (weq0 / 4 / h)) * ( 1+ (h / weq0) + (h / `pi / weq0) * (ln((4 * `pi * w / t) + 1) - (1 - (t / w)) / (1 + (t / 4 / `pi / w)))) * rsh / 2 / `pi / `z0 / h;

// Общие потери
            alpha = ad + ac2 + ar;
            beta  =  2 * `pi * sqrt(erf) * frequency / `C0;

        end
    endfunction // calcPropagation

analog begin

    begin : initializeInstance
    end // initializeInstance

    calcPropagation($freq);

    real z = zlf / `z0;

    //$strobe("alpha= %g", alpha);
    //$strobe("beta= %g", beta);


    real y = 1 / z;
    complex g = $complex(alpha, beta);
    complex n = 2.0 * cosh(g * l) + (z + y) * sinh(g * l);
    complex s11 = (z - y) * sinh(g * l) / n;
    complex s21 = 2.0 / n;

    S(p1,p1) <+ s11;
    S(p1,p2) <+ s21;
    S(p2,p1) <+ s21;
    S(p2,p2) <+ s11;

end // analog

endmodule
