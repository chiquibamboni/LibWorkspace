
nature sparameter
  access = S;
endnature

nature yparameter
  access = Y;
endnature

nature zparameter
  access = Z;
endnature

discipline sparameters
  flow sparameter;
enddiscipline

discipline yparameters
  flow yparameter;
enddiscipline

discipline zparameters
  flow zparameter;
enddiscipline

`define z0          50.0

`define C0          299792458.0
`define MU0         12.566370614e-7
`define Z0          376.73031346958504364963

`define pi          3.1415926535897932384626433832795029
`define pi_over_2   1.5707963267948966192313216916397514
`define one_over_pi 0.3183098861837906715377675267450287
`define two_over_pi 0.6366197723675813430755350534900574
`define euler       2.7182818284590452353602874713526625
`define ln2         0.6931471805599453094172321214581766

// IMPORTANT WARNING
// In c, c++, spectre, hspice natural logarithm - "log", and in VerilogA - "ln";
// In c, c++, spectre, hspice decimal logarithm - "log10", and in VerilogA - "log";

module MGAP(p1,p2) (*model_type="distributed" port_type="one_pole"*);  //  port_type: "one_pole" or "two_pole"

inout      p1,p2;
yparameters p1,p2;

(*desc="width",                   unit="m",           type="instance"*)                      parameter real w = 25u from (0.0:inf);
(*desc="length",                  unit="m",           type="instance"*)                      parameter real s = 10u from (0.0:inf);
//(*desc="dispersion model",                            type="instance", resolve_type="text"*) parameter string dispmodel = "Hammerstad";
//(*desc="model",                                       type="instance", resolve_type="text"*) parameter string model = "Wheeler";

(*desc="substrate permittivity relative to a vacuum", type="instance"*)                      parameter real er = 9.8 from (0.0:inf);
                                                                                             aliasparam eps = er;
(*desc="substrate height",        unit="m"            type="instance"*)                      parameter real h = 0.1m from (0.0:inf);
//(*desc="conductor thickness",     unit="m"            type="instance"*)                      parameter real t = 3u from (0.0:inf);
//(*desc="loss tangent",                                type="instance"*)                      parameter real tand = 2e-4 from (0.0:inf);
//(*desc="metal resistivity",                           type="instance"*)                      parameter real rho = 2.2e-8 from (0.0:inf);
//(*desc="surface roughness (RMS)",                     type="instance"*)                      parameter real d = 0.15e-6 from (0.0:inf);

(*desc="substrate",                                   type="instance", resolve_type="text"*) parameter string subst = "";


    analog function real sqr;
        input r;
        real r;
        sqr = r*r;
    endfunction

    analog function real cubic;
        input r;
        real r;
        cubic = r*r*r;
    endfunction

    analog function real quadr;
        input r;
        real r;
        quadr = r*r*r*r;
    endfunction

    analog function real coth;
        input r;
        real r;
        coth = 1.0/tanh(r);
    endfunction

    analog function real sech;
        input r;
        real r;
        sech = 1.0/cosh(r);
    endfunction


	real a, b, u, e, fu, zl;
	real dl, k, C12;
                    real W1, W2;
                    real Q1, Q2, Q3, Q4, Q5;
                    real Cs, Cp1, Cp2;
real e11, e22, e21;

    analog function real calcPropagation;
        input frequency;
        real frequency;
        begin
// расчет основных параметров
            u = w / h;
            a = 1 + ln((quadr(u) + sqr(u / 52)) / (quadr(u) + 0.432)) / 49 + ln(1 + cubic(u / 18.1)) / 18.7;
            b = 0.564 * pow((er - 0.9) / (er + 3), 0.053);
            e = (er + 1) / 2 + (er - 1) / 2 * pow(1 + 10 / u, -a * b);
            fu = 6 + (2 * `pi - 6) * exp(-pow(30.666 / u, 0.7528));
            zl = `Z0 / 2 / `pi / sqrt(e) * ln(fu / u + sqrt(1 + sqr(2 / u)));

            dl = 0.102 * (w + 0.106) / (w + 0.264) * (1.166 + (e + 1) / e * (0.9 + ln(w + 2.475)));
            k = 162611000;
            C12 = (sqrt(e) / (`C0 * zl)) * k * dl;

            W1 = w;
            W2 = w;

            Q5 = 1.23 / (1 + 0.12 * pow(((W2 / W1) - 1),0.9));
            Q1 = 0.04598 * ((0.03 + pow((W1 / h), Q5)) * (0.272 + 0.07 * er));
            Q2 = 0.107 * ((W1 / h) + 9) * pow((s / h),3.23) + 2.09 * pow((s / h ),1.05) * ((1.5 + 0.3 * (W1 /h ))/(1 + 0.6 * (W1 /h)));
            Q3 = exp(-0.5978 * pow((W2 / W1),1.35)) - 0.55;
            Q4 = exp(-0.5978 * pow((W1 / W2),1.35)) - 0.55;

            Cs = 500 * h * exp(-1.86 * (s / h)) * Q1 * (1 + 4.19 * (1 - exp(-0.785 * sqrt(h/W1) * W2 / W1)));
            Cp1 = C12 * ((Q2 + Q3) / (Q2 + 1));
            Cp2 = C12 * ((Q2 + Q4) / (Q2 + 1));



        end
    endfunction // calcPropagation

analog begin

    begin : initializeInstance
    end // initializeInstance

    calcPropagation($freq);

    //$strobe("Cs= %g", Cs);
    //$strobe("Cp1= %g", Cp1);
    //$strobe("Cp2= %g", Cp2);



    complex y11 = $complex(0, 2 * `pi * $freq * (Cs + Cp1) * (1e-12));
    complex y21 = $complex(0, 2 * `pi * $freq * Cs * (1e-12));
    complex y22 = $complex(0, 2 * `pi * $freq * (Cs + Cp2) * (1e-12)); ;

    Y(p1,p1) <+ y11;
    Y(p1,p2) <+ -y21;
    Y(p2,p1) <+ -y21;
    Y(p2,p2) <+ y22;

end // analog

endmodule
